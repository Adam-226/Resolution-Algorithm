## Algorithm Principles
The task of the algorithm is to write a function to implement first-order logic resolution inference. The input is a set of clauses (a collection of tuples), and the output is the entire resolution process, with each resolution step stored in a list and returned.
One key point to clarify in this algorithm is: what data types should be used to store each formula, clause, clause set, and temporary data required for implementing the resolution inference at different stages of the process. According to the algorithm requirements, the input clause set is a collection of tuples. I first convert it into a nested list data type, which helps to determine the order of the clauses and makes it easier to call list methods. For each atomic formula, the data type required is a string, but the string form is inconvenient when parsing the structure of the formula (such as predicates, polarity, variables, and constants). Therefore, I define a class to represent each atomic formula, where the class includes the polarity (0 or 1), predicate (a string), and parameters (a list of strings). This approach makes it more convenient to parse each atomic formula for resolution. Additionally, I need a function to convert the input atomic formula from a string into the corresponding class instance.
In the returned step list, each step is stored as a string. Therefore, I also need to convert the class instance of the formula back into the atomic formula string. Once the required data types are clarified, the next key part is the specific resolution algorithm. A single step of resolution involves finding two clauses that share the same predicate but have opposite polarities in their atomic formulas. After removing the two atomic formulas, the two clauses are merged into one (this may require unification, where variables are assigned constant values) and added to the clause set. The single-step resolution is repeated until either an empty clause is obtained or no new clauses are generated, at which point the function terminates.
## Algorithm Analysis
It can be observed that the entire resolution process is quite tedious, mainly due to the complex output requirements of the algorithm. In fact, the logic itself is not complicated. The entire logic can be described as follows: Traverse all atomic formulas in two clauses to find two atomic formulas that meet the resolution requirements (opposite polarities and the same predicate). Then, consider the cases based on their parameters. If the parameters of the two atomic formulas are the same, no unification is needed; the resolution can proceed directly. A new list is created with the merged clause that excludes the two atomic formulas. If the new clause is not already in the clause set, the operation details for this step are represented as a string and added to the entire resolution process string. If the parameters of the two atomic formulas are different, unification is required, and the variables are assigned constant values to make the parameters the same, continuing the resolution. The operation details are also added to the resolution process string. If an empty clause is obtained, the resolution is complete, and the function returns 0; otherwise, it returns 1.
All three examples ultimately resolved to an empty clause, successfully completing first-order logic resolution inference. However, compared to the output examples given by the instructor, the resolution steps are somewhat excessive. From a human perspective, the efficiency is indeed lower because my algorithm directly traverses the clauses for resolution and lists all possible resolution steps, many of which are unnecessary. This requires optimizing the clause selection algorithm in the code for better resolution performance.
Since I use a brute-force traversal method to resolve the clauses pairwise, the efficiency is not high. In the worst case, the time complexity is O(n^3) (where n is the number of clauses in the clause set). Therefore, the algorithm for selecting two clauses needs to be improved to reduce time complexity. However, I have not yet come up with a better algorithm for this.
